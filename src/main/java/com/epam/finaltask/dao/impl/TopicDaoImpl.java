package com.epam.finaltask.dao.impl;

import com.epam.finaltask.dao.TopicDao;
import com.epam.finaltask.entity.Account;
import com.epam.finaltask.entity.Topic;
import org.apache.commons.io.IOUtils;
import org.apache.logging.log4j.Level;

import java.io.IOException;
import java.io.Reader;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.LinkedList;
import java.util.List;

/**
 * Class that implements CRUD and several other operations to work with database topics.
 */
class TopicDaoImpl extends AbstractDao<Topic> implements TopicDao {

    private static final String FIND_ALL_TOPICS = "SELECT topic_id, closed, title, text, date_posted, account_id, hidden " +
            "FROM topic";
    private static final String FIND_TOPIC_BY_ID = "SELECT closed, title, text, date_posted, account_id, hidden " +
            "FROM topic WHERE topic_id = ?";
    private static final String FIND_TOPICS_BY_ACCOUNT_ID = "SELECT topic_id, closed, title, text, date_posted, account_id, hidden " +
            "FROM topic WHERE account_id = ?";
    private static final String INSERT_TOPIC = "INSERT INTO topic(closed, title, text, date_posted, account_id, hidden) " +
            "VALUES(?,?,?,?,?,?)";
    private static final String INSERT_TOPIC_GENERATED_CURRENT_DATE =
            "INSERT INTO topic(closed, title, text, date_posted, account_id, hidden) VALUES(?,?,?,now(),?,?)";
    private static final String DELETE_TOPIC_BY_ID = "DELETE FROM topic where topic_id = ?";
    private static final String UPDATE_TOPIC_BY_ID = "UPDATE topic " +
            "SET closed = ?, title = ?, text = ?, date_posted = ?, account_id = ?, hidden = ? " +
            "WHERE topic_id = ?";
    private static final String COUNT_TOPICS = "SELECT COUNT(1) FROM topic";
    private static final String FIND_TOPICS_IN_RANGE_SORT_BY_DATE_DESC = "SELECT topic_id, closed, title, text, " +
            "date_posted, account_id, hidden " +
            "FROM topic " +
            "ORDER BY date_posted DESC LIMIT ? OFFSET ?";
    private static final String FIND_TOPICS_IN_RANGE_SORT_BY_DATE_DESC_NO_HIDDEN = "SELECT topic_id, closed, title, text, " +
            "date_posted, account_id, hidden " +
            "FROM topic " +
            "WHERE hidden = 0 " +
            "ORDER BY date_posted DESC LIMIT ? OFFSET ?";
    private static final String COUNT_TOPICS_NO_HIDDEN = "SELECT COUNT(1) FROM topic WHERE hidden = 0";

    /**
     * Creates TopicDaoImpl using chosen connectionManager
     * @param connectionManager Connection manager that provides connection to the DAO
     */
    TopicDaoImpl(AbstractConnectionManager connectionManager) {
        super(connectionManager);
    }


    @Override
    public List<Topic> findTopicsByAccountId(long accountId) throws PersistenceException {
        try (PreparedStatement statement = getConnection().prepareStatement(FIND_TOPICS_BY_ACCOUNT_ID)){
            statement.setLong(1, accountId);
            try (ResultSet resultSet = statement.executeQuery()) {
                return constructTopicsFromResultSet(resultSet);
            } catch (IOException e) {
                throw new PersistenceException("IOException while working with clob reader", e);
            }
        } catch (SQLException e) {
            throw new PersistenceException("SQLException while executing findAll", e);
        }
    }

    /**
     * Adds topic to the database with date generated by the database.
     * @param entity Topic to add.
     * @return {@code true} if topic was successfully added, else returns {@code false}
     * @throws PersistenceException If SQLException is thrown
     */
    @Override
    public boolean createWithGeneratedDate(Topic entity) throws PersistenceException {
        Connection connection = getConnection();
        try (PreparedStatement statement = connection.prepareStatement(INSERT_TOPIC_GENERATED_CURRENT_DATE)){
            statement.setBoolean(1, entity.isClosed());

            Clob titleClob = connection.createClob();
            titleClob.setString(1, entity.getTitle());
            statement.setClob(2, titleClob);

            Clob textClob = connection.createClob();
            textClob.setString(1, entity.getText());
            statement.setClob(3, textClob);

            Account account = entity.getAccount();
            if (account == null) {
                throw new PersistenceException("Unable to create topic without specified account");
            }
            statement.setLong(4, account.getAccountId());
            statement.setBoolean(5, entity.isHidden());
            int result = statement.executeUpdate();
            return result == 1;
        } catch (SQLException e) {
            throw new PersistenceException("SQLException while creating", e);
        }
    }

    /**
     * Finds all topics from the database.
     * @return All topics from the database
     * @throws PersistenceException If SQLException thrown
     */
    @Override
    public List<Topic> findAll() throws PersistenceException {
        try (PreparedStatement statement = getConnection().prepareStatement(FIND_ALL_TOPICS)){
            try (ResultSet resultSet = statement.executeQuery()) {
                return constructTopicsFromResultSet(resultSet);
            } catch (IOException e) {
                throw new PersistenceException("IOException while working with clob reader", e);
            }
        } catch (SQLException e) {
            throw new PersistenceException("SQLException while executing findAll", e);
        }
    }

    /**
     * Finds topic by id.
     * @param id Id of the entity to find
     * @return Topic if it was found, else returns null
     * @throws PersistenceException if SQLException or IOException thrown
     */
    @Override
    public Topic findEntityById(long id) throws PersistenceException {
        Topic topic = null;
        try (PreparedStatement statement = getConnection().prepareStatement(FIND_TOPIC_BY_ID)){
            statement.setLong(1, id);
            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    boolean closed = resultSet.getBoolean(1);
                    Clob titleClob = resultSet.getClob(2);
                    Clob textClob = resultSet.getClob(3);
                    LocalDateTime date = resultSet.getObject(4, LocalDateTime.class);
                    long accountId = resultSet.getLong(5);
                    boolean hidden = resultSet.getBoolean(6);

                    Account account = new Account(accountId);

                    String title;
                    try (Reader titleReader = titleClob.getCharacterStream()) {
                        title = IOUtils.toString(titleReader);
                    }

                    String text;
                    try (Reader textReader = textClob.getCharacterStream()) {
                        text = IOUtils.toString(textReader);
                    }

                    topic = new Topic(id, title, text, date, account, closed, hidden);
                }
            } catch (IOException e) {
                throw new PersistenceException("IOException while working with clob reader", e);
            }
        } catch (SQLException e) {
            throw new PersistenceException("SQLException while finding by id", e);
        }
        return topic;
    }

    /**
     * Returns query that deletes topic by id.
     * @return Query that deletes topic by id
     */
    @Override
    public String getDeleteByIdQuery() {
        return DELETE_TOPIC_BY_ID;
    }

    /**
     * Adds topic to the database.
     * @param entity Entity to add
     * @return {@code true} if topic was successfully added, else return {@code false}
     * @throws PersistenceException If SQLException thrown
     */
    @Override
    public boolean create(Topic entity) throws PersistenceException {
        if (entity == null) {
            return false;
        }
        Connection connection = getConnection();
        try (PreparedStatement statement = connection.prepareStatement(INSERT_TOPIC)){
            statement.setBoolean(1, entity.isClosed());

            Clob titleClob = connection.createClob();
            titleClob.setString(1, entity.getTitle());
            statement.setClob(2, titleClob);

            Clob textClob = connection.createClob();
            textClob.setString(1, entity.getText());
            statement.setClob(3, textClob);
            statement.setObject(4, entity.getDate());
            Account account = entity.getAccount();
            if (account == null) {
                return false;
            }
            statement.setLong(5, account.getAccountId());
            statement.setBoolean(6, entity.isHidden());
            statement.setLong(5, account.getAccountId());
            int result = statement.executeUpdate();
            return result == 1;
        } catch (SQLException e) {
            throw new PersistenceException("SQLException while creating", e);
        }
    }

    /**
     * Updates database topic.
     * @param entity Entity to update
     * @return {@code true} if topic was successfully updated, else return {@code false}
     * @throws PersistenceException If SQLException thrown
     */
    @Override
    public int update(Topic entity) throws PersistenceException {
        if (entity == null) {
            return 0;
        }
        Connection connection = getConnection();
        try (PreparedStatement statement = connection.prepareStatement(UPDATE_TOPIC_BY_ID)){
            statement.setBoolean(1, entity.isClosed());

            Clob titleClob = connection.createClob();
            titleClob.setString(1, entity.getTitle());
            statement.setClob(2, titleClob);

            Clob textClob = connection.createClob();
            textClob.setString(1, entity.getText());
            statement.setClob(3, textClob);

            statement.setObject(4, entity.getDate());
            statement.setLong(5, entity.getAccount().getAccountId());
            statement.setBoolean(6, entity.isHidden());
            statement.setLong(7, entity.getTopicId());
            return statement.executeUpdate();
        } catch (SQLException e) {
            throw new PersistenceException("SQLException while updating", e);
        }
    }

    /**
     * Counts all database topics.
     * @param countHidden Determines if hidden topics will be counted
     * @return number of database topics
     * @throws PersistenceException If SQLException is thrown or if the ResultSet is empty
     */
    public int countTopics(boolean countHidden) throws PersistenceException {
        String query = COUNT_TOPICS;
        if (!countHidden) {
            query = COUNT_TOPICS_NO_HIDDEN;
        }
        Connection connection = getConnection();
        try (PreparedStatement statement = connection.prepareStatement(query)) {
            try (ResultSet resultSet = statement.executeQuery()) {
                if(resultSet.next()) {
                    return resultSet.getInt(1);
                } else {
                    throw new PersistenceException("unable to get result from the count operation");
                }
            }
        } catch (SQLException e) {
            throw new PersistenceException(e);
        }
    }

    /**
     * Finds all topics on the chosen page.
     * @param currentPage Page to take topics from
     * @param numberOfTopicsPerPage Number of topics per page
     * @param showHidden Flag that determines if hidden topics will be fetched
     * @return Topics from the chosen page
     * @throws PersistenceException If SQLException is thrown while working with database
     */
    @Override
    public List<Topic> findPageTopics(int currentPage, int numberOfTopicsPerPage, boolean showHidden) throws PersistenceException {
        String query = FIND_TOPICS_IN_RANGE_SORT_BY_DATE_DESC;
        if (!showHidden) {
            query = FIND_TOPICS_IN_RANGE_SORT_BY_DATE_DESC_NO_HIDDEN;
        }
        try (PreparedStatement statement = getConnection().prepareStatement(query)){
            statement.setInt(1, numberOfTopicsPerPage);
            statement.setInt(2, (currentPage - 1) * numberOfTopicsPerPage);
            try (ResultSet resultSet = statement.executeQuery()) {
                return constructTopicsFromResultSet(resultSet);
            } catch (IOException e) {
                throw new PersistenceException("IOException while working with clob");
            }
        } catch (SQLException e) {
            throw new PersistenceException("SQLException while finding page topics", e);
        }
    }

    /**
     * Creates list of topics using result set.
     * ResultSet should contain next values in specific columns ({@code value - columnIndex}):
     * topicId - 1, closed - 2, title - 3, text - 4, date - 5, accountId - 6, hidden - 7.
     * @param resultSet ResultSet which data is used to create list of topics
     * @return List of topics created using result set data
     * @throws SQLException If exception is thrown while getting values from the result set.
     * @throws IOException If clob character streams can't be acquired
     */
    private List<Topic> constructTopicsFromResultSet(ResultSet resultSet) throws SQLException, IOException {
        List<Topic> list = new LinkedList<>();
        while (resultSet.next()) {
            long topicId = resultSet.getLong(1);
            boolean closed = resultSet.getBoolean(2);
            Clob titleClob = resultSet.getClob(3);
            Clob textClob = resultSet.getClob(4);
            LocalDateTime date = resultSet.getObject(5, LocalDateTime.class);
            long accountId = resultSet.getLong(6);
            boolean hidden = resultSet.getBoolean(7);

            Account account = new Account(accountId);

            String title;
            try (Reader titleReader = titleClob.getCharacterStream()) {
                title = IOUtils.toString(titleReader);
            }

            String text = null;
            if (textClob != null) {
                try (Reader textReader = textClob.getCharacterStream()) {
                    text = IOUtils.toString(textReader);
                }
            }
            Topic topic = new Topic(topicId, title, text, date, account, closed, hidden);
            logger.log(Level.DEBUG, "Topic created from the ResultSet: " + topic);
            list.add(topic);
        }
        return list;
    }
}
